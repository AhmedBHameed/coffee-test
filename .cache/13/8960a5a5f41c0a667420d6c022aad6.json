{"id":"pBGv","dependencies":[{"name":"/home/ahmed/Desktop/WWW/coffee-test/package.json","includedInParent":true,"mtime":1568977643888},{"name":"/home/ahmed/Desktop/WWW/coffee-test/node_modules/process/package.json","includedInParent":true,"mtime":1548862039549}],"generated":{"js":"\nvar $pBGv$exports = {};\n// shim for using process in browser\nvar $pBGv$var$process = $pBGv$exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar $pBGv$var$cachedSetTimeout;\nvar $pBGv$var$cachedClearTimeout;\n\nfunction $pBGv$var$defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction $pBGv$var$defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      $pBGv$var$cachedSetTimeout = setTimeout;\n    } else {\n      $pBGv$var$cachedSetTimeout = $pBGv$var$defaultSetTimout;\n    }\n  } catch (e) {\n    $pBGv$var$cachedSetTimeout = $pBGv$var$defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      $pBGv$var$cachedClearTimeout = clearTimeout;\n    } else {\n      $pBGv$var$cachedClearTimeout = $pBGv$var$defaultClearTimeout;\n    }\n  } catch (e) {\n    $pBGv$var$cachedClearTimeout = $pBGv$var$defaultClearTimeout;\n  }\n})();\n\nfunction $pBGv$var$runTimeout(fun) {\n  if ($pBGv$var$cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if (($pBGv$var$cachedSetTimeout === $pBGv$var$defaultSetTimout || !$pBGv$var$cachedSetTimeout) && setTimeout) {\n    $pBGv$var$cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return $pBGv$var$cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return $pBGv$var$cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return $pBGv$var$cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction $pBGv$var$runClearTimeout(marker) {\n  if ($pBGv$var$cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if (($pBGv$var$cachedClearTimeout === $pBGv$var$defaultClearTimeout || !$pBGv$var$cachedClearTimeout) && clearTimeout) {\n    $pBGv$var$cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return $pBGv$var$cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return $pBGv$var$cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return $pBGv$var$cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar $pBGv$var$queue = [];\nvar $pBGv$var$draining = false;\nvar $pBGv$var$currentQueue;\nvar $pBGv$var$queueIndex = -1;\n\nfunction $pBGv$var$cleanUpNextTick() {\n  if (!$pBGv$var$draining || !$pBGv$var$currentQueue) {\n    return;\n  }\n\n  $pBGv$var$draining = false;\n\n  if ($pBGv$var$currentQueue.length) {\n    $pBGv$var$queue = $pBGv$var$currentQueue.concat($pBGv$var$queue);\n  } else {\n    $pBGv$var$queueIndex = -1;\n  }\n\n  if ($pBGv$var$queue.length) {\n    $pBGv$var$drainQueue();\n  }\n}\n\nfunction $pBGv$var$drainQueue() {\n  if ($pBGv$var$draining) {\n    return;\n  }\n\n  var timeout = $pBGv$var$runTimeout($pBGv$var$cleanUpNextTick);\n  $pBGv$var$draining = true;\n  var len = $pBGv$var$queue.length;\n\n  while (len) {\n    $pBGv$var$currentQueue = $pBGv$var$queue;\n    $pBGv$var$queue = [];\n\n    while (++$pBGv$var$queueIndex < len) {\n      if ($pBGv$var$currentQueue) {\n        $pBGv$var$currentQueue[$pBGv$var$queueIndex].run();\n      }\n    }\n\n    $pBGv$var$queueIndex = -1;\n    len = $pBGv$var$queue.length;\n  }\n\n  $pBGv$var$currentQueue = null;\n  $pBGv$var$draining = false;\n  $pBGv$var$runClearTimeout(timeout);\n}\n\n$pBGv$var$process.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  $pBGv$var$queue.push(new $pBGv$var$Item(fun, args));\n\n  if ($pBGv$var$queue.length === 1 && !$pBGv$var$draining) {\n    $pBGv$var$runTimeout($pBGv$var$drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction $pBGv$var$Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\n$pBGv$var$Item.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\n$pBGv$var$process.title = 'browser';\n$pBGv$var$process.env = {};\n$pBGv$var$process.argv = [];\n$pBGv$var$process.version = ''; // empty string to avoid regexp issues\n\n$pBGv$var$process.versions = {};\n\nfunction $pBGv$var$noop() {}\n\n$pBGv$var$process.on = $pBGv$var$noop;\n$pBGv$var$process.addListener = $pBGv$var$noop;\n$pBGv$var$process.once = $pBGv$var$noop;\n$pBGv$var$process.off = $pBGv$var$noop;\n$pBGv$var$process.removeListener = $pBGv$var$noop;\n$pBGv$var$process.removeAllListeners = $pBGv$var$noop;\n$pBGv$var$process.emit = $pBGv$var$noop;\n$pBGv$var$process.prependListener = $pBGv$var$noop;\n$pBGv$var$process.prependOnceListener = $pBGv$var$noop;\n\n$pBGv$var$process.listeners = function (name) {\n  return [];\n};\n\n$pBGv$var$process.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\n$pBGv$var$process.cwd = function () {\n  return '/';\n};\n\n$pBGv$var$process.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\n$pBGv$var$process.umask = function () {\n  return 0;\n};"},"sourceMaps":null,"error":null,"hash":"569d40674bde5ebee62d045f4f4c0994","cacheData":{"env":{},"imports":{},"exports":{},"wildcards":[],"sideEffects":true,"isCommonJS":true}}